
-- ============================================================
-- LearnSphere Supabase Schema (idempotent)
-- This schema is designed to match the current frontend data model:
-- - Profiles (auth.users extension)
-- - Courses + Lessons
-- - Enrollments + Lesson Progress
-- - Traceable XP (points) + Badges
-- ============================================================

-- Extensions
create extension if not exists "uuid-ossp";

-- =========================
-- PROFILES
-- =========================
create table if not exists public.profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  email text unique,
  full_name text,
  avatar_url text,
  role text default 'learner' check (role in ('admin', 'instructor', 'learner')),
  points integer default 0,
  last_login_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.profiles add column if not exists last_login_at timestamp with time zone;

alter table public.profiles enable row level security;

drop policy if exists "Public profiles are viewable by everyone" on public.profiles;
create policy "Public profiles are viewable by everyone"
  on public.profiles for select using (true);

drop policy if exists "Users can insert their own profile" on public.profiles;
create policy "Users can insert their own profile"
  on public.profiles for insert with check (auth.uid() = id);

drop policy if exists "Users can update their own profile" on public.profiles;
create policy "Users can update their own profile"
  on public.profiles for update using (auth.uid() = id);

-- Create profile on signup (auth trigger)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, role, avatar_url)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name'),
    coalesce(new.raw_user_meta_data->>'role', 'learner'),
    coalesce(new.raw_user_meta_data->>'avatar_url', 'https://api.dicebear.com/9.x/notionists/svg?seed=' || new.id || '&backgroundColor=b6e3f4')
  )
  on conflict (id) do update set
    email = excluded.email,
    full_name = excluded.full_name;

  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- =========================
-- COURSES
-- Use bigint IDs to match current frontend routing (parseInt(courseId))
-- =========================
create table if not exists public.courses (
  id bigint generated by default as identity primary key,
  title text not null,
  description text,
  tags text[] default '{}'::text[],
  image_url text,
  website text,
  visibility text default 'everyone',
  access text default 'payment',
  price numeric default 0,
  published boolean default false,
  views integer default 0,
  certificate_enabled boolean default true,
  attendees jsonb default '[]'::jsonb,
  author_id uuid references public.profiles(id),
  responsible_id uuid references public.profiles(id),
  admin_id uuid references public.profiles(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Backward/forward compatible column adds
alter table public.courses add column if not exists attendees jsonb default '[]'::jsonb;
alter table public.courses add column if not exists responsible_id uuid references public.profiles(id);
alter table public.courses add column if not exists admin_id uuid references public.profiles(id);

alter table public.courses enable row level security;

drop policy if exists "Courses are viewable by everyone" on public.courses;
create policy "Courses are viewable by everyone"
  on public.courses for select using (true);

drop policy if exists "Instructors and Admins can create courses" on public.courses;
create policy "Instructors and Admins can create courses"
  on public.courses for insert with check (
    exists (
      select 1 from public.profiles
      where public.profiles.id = auth.uid()
        and public.profiles.role in ('admin', 'instructor')
    )
  );

drop policy if exists "Authors can update their own courses" on public.courses;
create policy "Authors can update their own courses"
  on public.courses for update using (
    auth.uid() = author_id or
    auth.uid() = responsible_id or
    auth.uid() = admin_id or
    exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
  );

drop policy if exists "Authors can delete their own courses" on public.courses;
create policy "Authors can delete their own courses"
  on public.courses for delete using (
    auth.uid() = author_id or
    auth.uid() = responsible_id or
    auth.uid() = admin_id or
    exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
  );

-- =========================
-- LESSONS
-- =========================
create table if not exists public.lessons (
  id bigint generated by default as identity primary key,
  course_id bigint references public.courses(id) on delete cascade not null,
  title text not null,
  description text,
  type text check (type in ('video', 'document', 'quiz', 'image')),
  content_url text,
  duration integer,
  allow_download boolean default false,
  attachments jsonb default '[]'::jsonb,
  quiz_id bigint,
  order_index integer default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.lessons enable row level security;

drop policy if exists "Lessons are viewable by everyone" on public.lessons;
create policy "Lessons are viewable by everyone"
  on public.lessons for select using (true);

drop policy if exists "Instructors can manage lessons" on public.lessons;
create policy "Instructors can manage lessons"
  on public.lessons for all
  using (
    exists (
      select 1 from public.courses
      where public.courses.id = public.lessons.course_id
        and (
          public.courses.author_id = auth.uid()
          or public.courses.responsible_id = auth.uid()
          or public.courses.admin_id = auth.uid()
          or exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
        )
    )
  )
  with check (
    exists (
      select 1 from public.courses
      where public.courses.id = public.lessons.course_id
        and (
          public.courses.author_id = auth.uid()
          or public.courses.responsible_id = auth.uid()
          or public.courses.admin_id = auth.uid()
          or exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
        )
    )
  );

-- =========================
-- ENROLLMENTS
-- Keep progress/status here for fast reads
-- =========================
create table if not exists public.enrollments (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  course_id bigint references public.courses(id) on delete cascade not null,
  enrolled_at timestamp with time zone default timezone('utc'::text, now()) not null,
  start_date timestamp with time zone,
  completed_date timestamp with time zone,
  status text default 'not-started' check (status in ('not-started', 'in-progress', 'completed')),
  progress integer default 0 check (progress >= 0 and progress <= 100),
  time_spent integer default 0,
  unique(user_id, course_id)
);

alter table public.enrollments enable row level security;

drop policy if exists "Users can view their own enrollments" on public.enrollments;
create policy "Users can view their own enrollments"
  on public.enrollments for select using (auth.uid() = user_id);

drop policy if exists "Users can enroll themselves" on public.enrollments;
create policy "Users can enroll themselves"
  on public.enrollments for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update their own enrollments" on public.enrollments;
create policy "Users can update their own enrollments"
  on public.enrollments for update using (auth.uid() = user_id);

-- =========================
-- LESSON PROGRESS
-- =========================
create table if not exists public.progress (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  lesson_id bigint references public.lessons(id) on delete cascade not null,
  completed_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, lesson_id)
);

alter table public.progress enable row level security;

drop policy if exists "Users can view their own progress" on public.progress;
create policy "Users can view their own progress"
  on public.progress for select using (auth.uid() = user_id);

drop policy if exists "Users can mark lessons as complete" on public.progress;
create policy "Users can mark lessons as complete"
  on public.progress for insert with check (auth.uid() = user_id);

-- =========================
-- TRACEABLE POINTS (XP)
-- =========================
create table if not exists public.point_transactions (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  delta integer not null,
  reason text not null,
  metadata jsonb default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.point_transactions enable row level security;

drop policy if exists "Users can view their own point transactions" on public.point_transactions;
create policy "Users can view their own point transactions"
  on public.point_transactions for select using (auth.uid() = user_id);

drop policy if exists "Users can insert their own point transactions" on public.point_transactions;
create policy "Users can insert their own point transactions"
  on public.point_transactions for insert with check (auth.uid() = user_id);

-- Award points atomically: write transaction + increment profile.points
create or replace function public.award_points(p_user_id uuid, p_delta integer, p_reason text, p_metadata jsonb default '{}'::jsonb)
returns integer as $$
declare
  new_points integer;
begin
  insert into public.point_transactions (user_id, delta, reason, metadata)
  values (p_user_id, p_delta, p_reason, coalesce(p_metadata, '{}'::jsonb));

  update public.profiles
    set points = coalesce(points, 0) + p_delta
    where id = p_user_id
    returning points into new_points;

  return new_points;
end;
$$ language plpgsql security definer;

revoke all on function public.award_points(uuid, integer, text, jsonb) from public;
grant execute on function public.award_points(uuid, integer, text, jsonb) to authenticated;

-- =========================
-- BADGES
-- =========================
create table if not exists public.badges (
  badge_key text primary key,
  name text not null,
  points_required integer not null,
  icon text,
  color text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists public.user_badges (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  badge_key text references public.badges(badge_key) on delete cascade not null,
  earned_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, badge_key)
);

alter table public.badges enable row level security;
alter table public.user_badges enable row level security;

drop policy if exists "Badges are viewable by everyone" on public.badges;
create policy "Badges are viewable by everyone"
  on public.badges for select using (true);

drop policy if exists "Users can view their own badges" on public.user_badges;
create policy "Users can view their own badges"
  on public.user_badges for select using (auth.uid() = user_id);

drop policy if exists "Users can insert their own badges" on public.user_badges;
create policy "Users can insert their own badges"
  on public.user_badges for insert with check (auth.uid() = user_id);

-- Seed default badges (matches frontend BADGE_LEVELS)
insert into public.badges (badge_key, name, points_required, icon, color)
values
  ('newbie', 'Newbie', 0, 'Sprout', 'text-gray-400'),
  ('explorer', 'Explorer', 20, 'Search', 'text-green-500'),
  ('achiever', 'Achiever', 40, 'Star', 'text-blue-500'),
  ('specialist', 'Specialist', 60, 'Gem', 'text-purple-500'),
  ('expert', 'Expert', 80, 'Trophy', 'text-orange-500'),
  ('master', 'Master', 100, 'Crown', 'text-red-500')
on conflict (badge_key) do update set
  name = excluded.name,
  points_required = excluded.points_required,
  icon = excluded.icon,
  color = excluded.color;

-- =========================
-- LOGIN EVENTS (TRACEABLE)
-- =========================
create table if not exists public.login_events (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  event text default 'login' check (event in ('login', 'logout')),
  metadata jsonb default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.login_events enable row level security;

drop policy if exists "Users can insert their own login events" on public.login_events;
create policy "Users can insert their own login events"
  on public.login_events for insert with check (auth.uid() = user_id);

drop policy if exists "Users can view their own login events" on public.login_events;
create policy "Users can view their own login events"
  on public.login_events for select using (auth.uid() = user_id);

drop policy if exists "Admins can view all login events" on public.login_events;
create policy "Admins can view all login events"
  on public.login_events for select using (
    exists (select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin')
  );
